name: Merge Community PR After Checks

'on':
  workflow_run:
    workflows: ['PR Quality Check']
    types: [completed]
  pull_request_target:
    types: [labeled]

permissions: {}

jobs:
  merge:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: (github.event_name == 'pull_request_target' || github.event.workflow_run.conclusion == 'success') && github.repository == 'lingdojo/kana-dojo'
    env:
      AUTOMATION_PR_TOKEN: ${{ secrets.AUTOMATION_PR_TOKEN }}

    concurrency:
      group: community-merge-after-check-${{ github.event.pull_request.number || github.event.workflow_run.id || github.run_id }}
      cancel-in-progress: false

    steps:
      - name: Merge community PR
        if: (github.event_name != 'pull_request_target' || github.event.pull_request.head.repo.full_name == github.repository) && env.AUTOMATION_PR_TOKEN != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTOMATION_PR_TOKEN }}
          script: |
            async function sleep(ms) {
              return new Promise(function(resolve) { setTimeout(resolve, ms); });
            }

            async function resolvePrByHeadSha(headSha) {
              if (!headSha) {
                return null;
              }
              try {
                const { data: associatedPrs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  commit_sha: headSha
                });
                const openPr = (associatedPrs || []).find(function(pr) { return pr.state === 'open'; });
                return openPr || (associatedPrs || [])[0] || null;
              } catch (error) {
                console.log(`Could not resolve PR from SHA ${headSha}: ${error.message}`);
                return null;
              }
            }

            async function listAllPrFiles(prNumber) {
              return await github.paginate(github.rest.pulls.listFiles, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                per_page: 100
              });
            }

            let prNumber = null;
            let expectedHeadSha = null;

            if (context.eventName === 'workflow_run') {
              const run = context.payload.workflow_run;
              const prs = run.pull_requests || [];

              if (prs.length > 0 && prs[0].number) {
                prNumber = prs[0].number;
              } else {
                const fallbackPr = await resolvePrByHeadSha(run.head_sha);
                if (!fallbackPr || !fallbackPr.number) {
                  console.log(`No pull request associated with workflow_run ${run.id}; skipping.`);
                  return;
                }
                prNumber = fallbackPr.number;
              }
              expectedHeadSha = run.head_sha;
            } else {
              const pr = context.payload.pull_request;
              const label = context.payload.label;

              if (!label || label.name !== 'community-auto-merge') {
                console.log('Label event is not community-auto-merge; skipping');
                return;
              }

              prNumber = pr.number;
              expectedHeadSha = pr.head.sha;
            }

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            if (!pr.head || pr.head.sha !== expectedHeadSha) {
              console.log(`PR #${prNumber} head SHA does not match expected head SHA; skipping`);
              return;
            }

            if (pr.state !== 'open') {
              console.log(`PR #${prNumber} is not open`);
              return;
            }

            if (pr.draft) {
              console.log(`PR #${prNumber} is a draft`);
              return;
            }

            if (pr.head && pr.head.ref && pr.head.ref.startsWith('automation/')) {
              console.log(`PR #${prNumber} is an automation PR; skipping`);
              return;
            }

            const files = await listAllPrFiles(prNumber);
            const allowedPrefixes = ['community/content/'];
            const allowedFiles = new Set(['package-lock.json']);

            const outsideFiles = files
              .map(function(file) { return file.filename; })
              .filter(function(filename) {
                if (allowedFiles.has(filename)) return false;
                return !allowedPrefixes.some(function(prefix) { return filename.startsWith(prefix); });
              });

            if (outsideFiles.length > 0) {
              console.log(`PR #${prNumber} touches non-community files; skipping auto-merge. Examples: ${outsideFiles.slice(0, 5).join(', ')}`);
              return;
            }

            const invalidOps = files
              .filter(function(file) {
                if (!file.filename.startsWith('community/content/')) {
                  return false;
                }
                return file.status === 'removed' || file.status === 'renamed';
              })
              .map(function(file) { return `${file.filename} (${file.status})`; });

            if (invalidOps.length > 0) {
              console.log(`PR #${prNumber} has disallowed file operations for auto-merge: ${invalidOps.join(', ')}`);
              return;
            }

            if (context.eventName === 'pull_request_target') {
              const { data: runs } = await github.rest.actions.listWorkflowRunsForWorkflow({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'pr-check.yml',
                head_sha: expectedHeadSha,
                per_page: 1
              });

              const latestRun = (runs.workflow_runs && runs.workflow_runs[0]) ? runs.workflow_runs[0] : null;
              if (!latestRun || latestRun.conclusion !== 'success') {
                console.log(`PR #${prNumber} does not have a successful PR Quality Check run for this SHA yet`);
                return;
              }
            }

            if (pr.mergeable === false) {
              console.log(`PR #${prNumber} is not mergeable`);
              return;
            }

            const MAX_RETRIES = 10;
            for (let i = 1; i <= MAX_RETRIES; i += 1) {
              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  merge_method: 'squash'
                });
                console.log(`Merged community PR #${prNumber}`);
                return;
              } catch (e) {
                console.log(`Merge attempt ${i} failed: ${e.message}`);
                if (e.status === 409) {
                  try {
                    await github.rest.pulls.updateBranch({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber
                    });
                    console.log(`Requested branch update for PR #${prNumber}`);
                  } catch (updateErr) {
                    console.log(`Could not update branch: ${updateErr.message}`);
                  }
                }
                if (i < MAX_RETRIES) {
                  await sleep(5000);
                }
              }
            }

            throw new Error(`Failed to merge community PR #${prNumber}`);
