name: Manage Stale Community Issues

on:
  schedule:
    - cron: '0 * * * *'
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write

# Prevent race conditions with other community workflows
concurrency:
  group: community-stale-issues
  cancel-in-progress: true

jobs:
  manage-stale:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.repository == 'lingdojo/kana-dojo'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.AUTOMATION_PR_TOKEN }}

      - name: Process stale community issues
        id: stale-check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTOMATION_PR_TOKEN }}
          script: |
            const fs = require('fs');
            const templates = require('./.github/templates/messages.cjs');
            const t = templates.staleIssues;

            const themeBacklogPath = 'community/backlog/theme-backlog.json';
            const factsBacklogPath = 'community/backlog/facts-backlog.json';
            const proverbsBacklogPath = 'community/backlog/proverbs-backlog.json';
            const haikuBacklogPath = 'community/backlog/haiku-backlog.json';
            const triviaBacklogPath = 'community/backlog/trivia-backlog.json';
            const grammarBacklogPath = 'community/backlog/grammar-backlog.json';
            const animeQuotesBacklogPath = 'community/backlog/anime-quotes-backlog.json';
            const idiomsBacklogPath = 'community/backlog/idioms-backlog.json';
            const regionalDialectsBacklogPath = 'community/backlog/regional-dialects-backlog.json';
            const falseFriendsBacklogPath = 'community/backlog/false-friends-backlog.json';
            const culturalEtiquetteBacklogPath = 'community/backlog/cultural-etiquette-backlog.json';
            const exampleSentencesBacklogPath = 'community/backlog/example-sentences-backlog.json';
            const commonMistakesBacklogPath = 'community/backlog/common-mistakes-backlog.json';
            const videoGameQuotesBacklogPath = 'community/backlog/video-game-quotes-backlog.json';

            let issues = [];
            let page = 1;
            while (true) {
              const { data: pageItems } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: templates.labels.community,
                state: 'open',
                per_page: 100,
                page: page
              });
              issues = issues.concat(pageItems);
              if (!pageItems || pageItems.length < 100) {
                break;
              }
              page += 1;
            }

            const now = new Date();
            const WARNING_THRESHOLD_MS = templates.config.staleWarningAfterMs;   // 12 hours
            const CLOSE_THRESHOLD_MS = templates.config.staleCloseAfterMs;       // 18 hours
            const UNASSIGNED_CLOSE_THRESHOLD_MS = 10 * 60 * 60 * 1000; // 10 hours

            let needsCommit = false;
            let themes = JSON.parse(fs.readFileSync(themeBacklogPath, 'utf8'));
            let facts = JSON.parse(fs.readFileSync(factsBacklogPath, 'utf8'));
            let proverbs = JSON.parse(fs.readFileSync(proverbsBacklogPath, 'utf8'));
            let haiku = JSON.parse(fs.readFileSync(haikuBacklogPath, 'utf8'));
            let trivia = JSON.parse(fs.readFileSync(triviaBacklogPath, 'utf8'));
            let grammar = JSON.parse(fs.readFileSync(grammarBacklogPath, 'utf8'));
            let animeQuotes = JSON.parse(fs.readFileSync(animeQuotesBacklogPath, 'utf8'));
            let idioms = JSON.parse(fs.readFileSync(idiomsBacklogPath, 'utf8'));
            let regionalDialects = JSON.parse(fs.readFileSync(regionalDialectsBacklogPath, 'utf8'));
            let falseFriends = JSON.parse(fs.readFileSync(falseFriendsBacklogPath, 'utf8'));
            let culturalEtiquette = JSON.parse(fs.readFileSync(culturalEtiquetteBacklogPath, 'utf8'));
            let exampleSentences = JSON.parse(fs.readFileSync(exampleSentencesBacklogPath, 'utf8'));
            let commonMistakes = JSON.parse(fs.readFileSync(commonMistakesBacklogPath, 'utf8'));
            let videoGameQuotes = JSON.parse(fs.readFileSync(videoGameQuotesBacklogPath, 'utf8'));

            let skippedUnassigned = 0;
            let warnedAssigned = 0;
            let closedAssigned = 0;
            let warnedUnassigned = 0;
            let closedUnassigned = 0;

            function reenableBacklogItem(title, sourceLabel) {
              const sourceTag = sourceLabel ? ` (${sourceLabel})` : '';
              if (title.includes('Add New Color Theme:') || title.includes('Add Theme:')) {
                // Extract theme name from title (old and new format)
                const themeMatch = title.match(/Add (?:New Color )?Theme:\s*(.+?)\s*(?:—|\(good)/i);
                if (themeMatch) {
                  const themeName = themeMatch[1].trim();
                  const themeIndex = themes.findIndex(function(t) { return t.name === themeName; });
                  if (themeIndex !== -1 && !themes[themeIndex].completed) {
                    themes[themeIndex].issued = false;
                    needsCommit = true;
                    console.log(`Re-enabled theme: ${themeName}${sourceTag}`);
                  } else if (themeIndex !== -1 && themes[themeIndex].completed) {
                    console.log(`Theme "${themeName}" is already completed, not re-enabling`);
                  }
                }
              } else if (title.includes('Add Japan Fact #') || title.includes('Add new Japan Fact #')) {
                const factIdMatch = title.match(/#(\d+)/);
                if (factIdMatch) {
                  const factId = parseInt(factIdMatch[1]);
                  const factIndex = facts.findIndex(function(f) { return f.id === factId; });
                  if (factIndex !== -1 && !facts[factIndex].completed) {
                    facts[factIndex].issued = false;
                    needsCommit = true;
                    console.log(`Re-enabled fact #${factId}${sourceTag}`);
                  } else if (factIndex !== -1 && facts[factIndex].completed) {
                    console.log(`Fact #${factId} is already completed, not re-enabling`);
                  }
                }
              } else if (title.includes('Add Japanese Proverb #') || title.includes('Add new Japanese Proverb #')) {
                const proverbIdMatch = title.match(/#(\d+)/);
                if (proverbIdMatch) {
                  const proverbId = parseInt(proverbIdMatch[1]);
                  const proverbIndex = proverbs.findIndex(function(p) { return p.id === proverbId; });
                  if (proverbIndex !== -1 && !proverbs[proverbIndex].completed) {
                    proverbs[proverbIndex].issued = false;
                    needsCommit = true;
                    console.log(`Re-enabled proverb #${proverbId}${sourceTag}`);
                  } else if (proverbIndex !== -1 && proverbs[proverbIndex].completed) {
                    console.log(`Proverb #${proverbId} is already completed, not re-enabling`);
                  }
                }
              } else if (title.includes('Add Classic Japanese Haiku #') || title.includes('Add Japanese Haiku #') || title.includes('Add new Japanese Haiku #')) {
                const haikuIdMatch = title.match(/#(\d+)/);
                if (haikuIdMatch) {
                  const haikuId = parseInt(haikuIdMatch[1]);
                  const haikuIndex = haiku.findIndex(function(h) { return h.id === haikuId; });
                  if (haikuIndex !== -1 && !haiku[haikuIndex].completed) {
                    haiku[haikuIndex].issued = false;
                    needsCommit = true;
                    console.log(`Re-enabled haiku #${haikuId}${sourceTag}`);
                  } else if (haikuIndex !== -1 && haiku[haikuIndex].completed) {
                    console.log(`Haiku #${haikuId} is already completed, not re-enabling`);
                  }
                }
              } else if (title.includes('Add New Trivia Question #') || title.includes('Add Trivia Question #') || title.includes('Add new Trivia Question #')) {
                const triviaIdMatch = title.match(/#(\d+)/);
                if (triviaIdMatch) {
                  const triviaId = parseInt(triviaIdMatch[1]);
                  const triviaIndex = trivia.findIndex(function(q) { return q.id === triviaId; });
                  if (triviaIndex !== -1 && !trivia[triviaIndex].completed) {
                    trivia[triviaIndex].issued = false;
                    needsCommit = true;
                    console.log(`Re-enabled trivia #${triviaId}${sourceTag}`);
                  } else if (triviaIndex !== -1 && trivia[triviaIndex].completed) {
                    console.log(`Trivia #${triviaId} is already completed, not re-enabling`);
                  }
                }
              } else if (title.includes('Add New Grammar Point #') || title.includes('Add Grammar Point #') || title.includes('Add new Grammar Point #')) {
                const grammarIdMatch = title.match(/#(\d+)/);
                if (grammarIdMatch) {
                  const grammarId = parseInt(grammarIdMatch[1]);
                  const grammarIndex = grammar.findIndex(function(g) { return g.id === grammarId; });
                  if (grammarIndex !== -1 && !grammar[grammarIndex].completed) {
                    grammar[grammarIndex].issued = false;
                    needsCommit = true;
                    console.log(`Re-enabled grammar #${grammarId}${sourceTag}`);
                  } else if (grammarIndex !== -1 && grammar[grammarIndex].completed) {
                    console.log(`Grammar #${grammarId} is already completed, not re-enabling`);
                  }
                }
              } else if (title.includes('Add Famous Anime Quote #') || title.includes('Add Anime Quote #') || title.includes('Add new Anime Quote #')) {
                const quoteIdMatch = title.match(/#(\d+)/);
                if (quoteIdMatch) {
                  const quoteId = parseInt(quoteIdMatch[1]);
                  const quoteIndex = animeQuotes.findIndex(function(q) { return q.id === quoteId; });
                  if (quoteIndex !== -1 && !animeQuotes[quoteIndex].completed) {
                    animeQuotes[quoteIndex].issued = false;
                    needsCommit = true;
                    console.log(`Re-enabled anime quote #${quoteId}${sourceTag}`);
                  } else if (quoteIndex !== -1 && animeQuotes[quoteIndex].completed) {
                    console.log(`Anime quote #${quoteId} is already completed, not re-enabling`);
                  }
                }
              } else if (title.includes('Add New Japanese Idiom #') || title.includes('Add Japanese Idiom #') || title.includes('Add new Japanese Idiom #')) {
                const idiomIdMatch = title.match(/#(\d+)/);
                if (idiomIdMatch) {
                  const idiomId = parseInt(idiomIdMatch[1]);
                  const idiomIndex = idioms.findIndex(function(i) { return i.id === idiomId; });
                  if (idiomIndex !== -1 && !idioms[idiomIndex].completed) {
                    idioms[idiomIndex].issued = false;
                    needsCommit = true;
                    console.log(`Re-enabled idiom #${idiomId}${sourceTag}`);
                  } else if (idiomIndex !== -1 && idioms[idiomIndex].completed) {
                    console.log(`Idiom #${idiomId} is already completed, not re-enabling`);
                  }
                }
              } else if (title.includes('Add Regional Dialect Entry #') || title.includes('Add Dialect Entry #') || title.includes('Add new Dialect Entry #')) {
                const dialectIdMatch = title.match(/#(\d+)/);
                if (dialectIdMatch) {
                  const dialectId = parseInt(dialectIdMatch[1]);
                  const dialectIndex = regionalDialects.findIndex(function(d) { return d.id === dialectId; });
                  if (dialectIndex !== -1 && !regionalDialects[dialectIndex].completed) {
                    regionalDialects[dialectIndex].issued = false;
                    needsCommit = true;
                    console.log(`Re-enabled regional dialect #${dialectId}${sourceTag}`);
                  } else if (dialectIndex !== -1 && regionalDialects[dialectIndex].completed) {
                    console.log(`Regional dialect #${dialectId} is already completed, not re-enabling`);
                  }
                }
              } else if (title.includes('Add Japanese False Friend #') || title.includes('Add False Friend Pair #') || title.includes('Add new False Friend Pair #')) {
                const idMatch = title.match(/#(\d+)/);
                if (idMatch) {
                  const id = parseInt(idMatch[1]);
                  const idx = falseFriends.findIndex(function(i) { return i.id === id; });
                  if (idx !== -1 && !falseFriends[idx].completed) {
                    falseFriends[idx].issued = false;
                    needsCommit = true;
                    console.log(`Re-enabled false friend #${id}${sourceTag}`);
                  } else if (idx !== -1 && falseFriends[idx].completed) {
                    console.log(`False friend #${id} is already completed, not re-enabling`);
                  }
                }
              } else if (title.includes('Add Japanese Cultural Etiquette Tip #') || title.includes('Add Etiquette Tip #') || title.includes('Add new Etiquette Tip #')) {
                const idMatch = title.match(/#(\d+)/);
                if (idMatch) {
                  const id = parseInt(idMatch[1]);
                  const idx = culturalEtiquette.findIndex(function(i) { return i.id === id; });
                  if (idx !== -1 && !culturalEtiquette[idx].completed) {
                    culturalEtiquette[idx].issued = false;
                    needsCommit = true;
                    console.log(`Re-enabled cultural etiquette #${id}${sourceTag}`);
                  } else if (idx !== -1 && culturalEtiquette[idx].completed) {
                    console.log(`Cultural etiquette #${id} is already completed, not re-enabling`);
                  }
                }
              } else if (title.includes('Add Japanese Example Sentence #') || title.includes('Add Example Sentence #') || title.includes('Add new Example Sentence #')) {
                const idMatch = title.match(/#(\d+)/);
                if (idMatch) {
                  const id = parseInt(idMatch[1]);
                  const idx = exampleSentences.findIndex(function(i) { return i.id === id; });
                  if (idx !== -1 && !exampleSentences[idx].completed) {
                    exampleSentences[idx].issued = false;
                    needsCommit = true;
                    console.log(`Re-enabled example sentence #${id}${sourceTag}`);
                  } else if (idx !== -1 && exampleSentences[idx].completed) {
                    console.log(`Example sentence #${id} is already completed, not re-enabling`);
                  }
                }
              } else if (title.includes('Add Common Japanese Learner Mistake #') || title.includes('Add Learner Mistake #') || title.includes('Add new Learner Mistake #')) {
                const idMatch = title.match(/#(\d+)/);
                if (idMatch) {
                  const id = parseInt(idMatch[1]);
                  const idx = commonMistakes.findIndex(function(i) { return i.id === id; });
                  if (idx !== -1 && !commonMistakes[idx].completed) {
                    commonMistakes[idx].issued = false;
                    needsCommit = true;
                    console.log(`Re-enabled common mistake #${id}${sourceTag}`);
                  } else if (idx !== -1 && commonMistakes[idx].completed) {
                    console.log(`Common mistake #${id} is already completed, not re-enabling`);
                  }
                }
              } else if (title.includes('Add Famous Japanese Video Game Quote #') || title.includes('Add Video Game Quote #') || title.includes('Add new Video Game Quote #')) {
                const idMatch = title.match(/#(\d+)/);
                if (idMatch) {
                  const id = parseInt(idMatch[1]);
                  const idx = videoGameQuotes.findIndex(function(i) { return i.id === id; });
                  if (idx !== -1 && !videoGameQuotes[idx].completed) {
                    videoGameQuotes[idx].issued = false;
                    needsCommit = true;
                    console.log(`Re-enabled video game quote #${id}${sourceTag}`);
                  } else if (idx !== -1 && videoGameQuotes[idx].completed) {
                    console.log(`Video game quote #${id} is already completed, not re-enabling`);
                  }
                }
              }
            }

            for (const issue of issues) {
              const lastActivity = new Date(issue.updated_at);
              const timeSinceActivity = now - lastActivity;
              const hasWarning = issue.labels.some(function(l) { return l.name === templates.labels.staleWarning; });

              if (!issue.assignees || issue.assignees.length === 0) {
                if (timeSinceActivity >= UNASSIGNED_CLOSE_THRESHOLD_MS) {
                  console.log(`Closing stale unassigned issue #${issue.number}: ${issue.title}`);
                  closedUnassigned += 1;

                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    state: 'closed',
                    state_reason: 'not_planned'
                  });
                } else {
                  // Leave unassigned issues quiet until auto-close to avoid noisy bot comments
                  skippedUnassigned += 1;
                }
                continue;
              }

              if (timeSinceActivity >= CLOSE_THRESHOLD_MS) {
                console.log(`Closing stale issue #${issue.number}: ${issue.title}`);
                closedAssigned += 1;
                
                // Unassign the user before closing
                const assignees = issue.assignees.map(function(a) { return a.login; });
                if (assignees.length > 0) {
                  try {
                    await github.rest.issues.removeAssignees({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      assignees: assignees
                    });
                    console.log(`Unassigned ${assignees.join(', ')} from issue #${issue.number}`);
                  } catch (error) {
                    // Continue stale cleanup even if assignee removal races or fails for one issue
                    console.log(`Could not unassign issue #${issue.number}: ${error.message}`);
                  }
                }
                
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'closed',
                  state_reason: 'completed'
                });

                reenableBacklogItem(issue.title, 'assigned-stale-close');
                
              } else if (timeSinceActivity >= WARNING_THRESHOLD_MS && !hasWarning) {
                console.log(`Adding warning to issue #${issue.number}`);
                warnedAssigned += 1;
                
                const warningMsg = t.warning;
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: `${warningMsg.greeting} ${warningMsg.body}\n\n${warningMsg.action}\n\n${warningMsg.consequence}\n\n${warningMsg.footer}`
                });
                
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: [templates.labels.staleWarning]
                });
              }
            }

            console.log(`Stale issue summary: total=${issues.length}, skipped_unassigned=${skippedUnassigned}, warned_assigned=${warnedAssigned}, closed_assigned=${closedAssigned}, warned_unassigned=${warnedUnassigned}, closed_unassigned=${closedUnassigned}`);

            if (needsCommit) {
              fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
              fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
              fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
              fs.writeFileSync(haikuBacklogPath, JSON.stringify(haiku, null, 2));
              fs.writeFileSync(triviaBacklogPath, JSON.stringify(trivia, null, 2));
              fs.writeFileSync(grammarBacklogPath, JSON.stringify(grammar, null, 2));
              fs.writeFileSync(animeQuotesBacklogPath, JSON.stringify(animeQuotes, null, 2));
              fs.writeFileSync(idiomsBacklogPath, JSON.stringify(idioms, null, 2));
              fs.writeFileSync(regionalDialectsBacklogPath, JSON.stringify(regionalDialects, null, 2));
              fs.writeFileSync(falseFriendsBacklogPath, JSON.stringify(falseFriends, null, 2));
              fs.writeFileSync(culturalEtiquetteBacklogPath, JSON.stringify(culturalEtiquette, null, 2));
              fs.writeFileSync(exampleSentencesBacklogPath, JSON.stringify(exampleSentences, null, 2));
              fs.writeFileSync(commonMistakesBacklogPath, JSON.stringify(commonMistakes, null, 2));
              fs.writeFileSync(videoGameQuotesBacklogPath, JSON.stringify(videoGameQuotes, null, 2));
              core.setOutput('needs_commit', 'true');
            } else {
              core.setOutput('needs_commit', 'false');
            }

      - name: Commit backlog updates directly to main
        if: steps.stale-check.outputs.needs_commit == 'true'
        run: |
          git config user.name "てんとう虫"
          git config user.email "reservecrate@gmail.com"
          git add community/backlog/
          if git diff --cached --quiet; then
            echo "No backlog changes to commit"
            exit 0
          fi
          commit_msg="chore(automation): re-enable stale items in backlog"
          max_attempts=5
          attempt=1
          while [ "$attempt" -le "$max_attempts" ]; do
            git commit -m "$commit_msg"
            if git pull --rebase origin main && git push origin HEAD:main; then
              echo "Backlog push succeeded on attempt $attempt"
              exit 0
            fi
            echo "Backlog push attempt $attempt failed; retrying..."
            git rebase --abort || true
            git fetch origin main
            git reset --hard origin/main
            git add community/backlog/
            if git diff --cached --quiet; then
              echo "No backlog changes remain after sync"
              exit 0
            fi
            attempt=$((attempt + 1))
          done
          echo "Failed to push backlog updates after $max_attempts attempts"
          exit 1
