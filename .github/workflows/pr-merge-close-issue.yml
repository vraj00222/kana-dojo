name: Close Issue on PR Merge

on:
  pull_request_target:
    types: [closed]

permissions:
  issues: write
  pull-requests: write
  contents: write

# Prevent overlapping runs for the same PR
concurrency:
  group: community-pr-merge-close-issue
  cancel-in-progress: false

jobs:
  close-issue:
    runs-on: ubuntu-latest
    # Skip automation PRs to save GitHub Actions minutes
    if: |
      github.event.pull_request.merged == true &&
      !startsWith(github.event.pull_request.head.ref, 'automation/')

    steps:
      - name: Checkout for templates
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.AUTOMATION_PR_TOKEN }}

      - name: Find and close related issue
        id: close-issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTOMATION_PR_TOKEN }}
          script: |
            const fs = require('fs');
            const templates = require('./.github/templates/messages.cjs');
            const t = templates.prMerge.issueComment;

            const themeBacklogPath = 'community/backlog/theme-backlog.json';
            const factsBacklogPath = 'community/backlog/facts-backlog.json';
            const proverbsBacklogPath = 'community/backlog/proverbs-backlog.json';
            const haikuBacklogPath = 'community/backlog/haiku-backlog.json';
            const triviaBacklogPath = 'community/backlog/trivia-backlog.json';
            const grammarBacklogPath = 'community/backlog/grammar-backlog.json';
            const animeQuotesBacklogPath = 'community/backlog/anime-quotes-backlog.json';
            const idiomsBacklogPath = 'community/backlog/idioms-backlog.json';
            const regionalDialectsBacklogPath = 'community/backlog/regional-dialects-backlog.json';
            const falseFriendsBacklogPath = 'community/backlog/false-friends-backlog.json';
            const culturalEtiquetteBacklogPath = 'community/backlog/cultural-etiquette-backlog.json';
            const exampleSentencesBacklogPath = 'community/backlog/example-sentences-backlog.json';
            const commonMistakesBacklogPath = 'community/backlog/common-mistakes-backlog.json';
            const videoGameQuotesBacklogPath = 'community/backlog/video-game-quotes-backlog.json';

            const prTitle = context.payload.pull_request.title;
            const prTitleLower = prTitle.toLowerCase();
            const prBody = context.payload.pull_request.body || '';
            const prNumber = context.payload.pull_request.number;
            const prAuthor = context.payload.pull_request.user.login;

            const isThemeContribution = prTitleLower.includes('theme');
            const isFactContribution = prTitleLower.includes('fact') && !prTitleLower.includes('proverb');
            const isProverbContribution = prTitleLower.includes('proverb');
            const isHaikuContribution = prTitleLower.includes('haiku');
            const isTriviaContribution = prTitleLower.includes('trivia');
            const isGrammarContribution = prTitleLower.includes('grammar');
            const isAnimeQuoteContribution = prTitleLower.includes('anime quote') || prTitleLower.includes('anime-quote') || prTitleLower.includes('animequote');
            const isIdiomContribution = prTitleLower.includes('idiom');
            const isRegionalDialectContribution = prTitleLower.includes('regional dialect') || prTitleLower.includes('regional-dialect') || prTitleLower.includes('regionaldialect');
            const isFalseFriendContribution = prTitleLower.includes('false friend') || prTitleLower.includes('false-friend');
            const isCulturalEtiquetteContribution = prTitleLower.includes('cultural etiquette') || prTitleLower.includes('cultural-etiquette');
            const isExampleSentenceContribution = prTitleLower.includes('example sentence') || prTitleLower.includes('example-sentence');
            const isCommonMistakeContribution = prTitleLower.includes('common mistake') || prTitleLower.includes('common-mistake');
            const isVideoGameQuoteContribution = prTitleLower.includes('video game quote') || prTitleLower.includes('videogame quote') || prTitleLower.includes('video-game-quote');

            if (!isThemeContribution && !isFactContribution && !isProverbContribution && !isHaikuContribution && !isTriviaContribution && !isGrammarContribution && !isAnimeQuoteContribution && !isIdiomContribution && !isRegionalDialectContribution && !isFalseFriendContribution && !isCulturalEtiquetteContribution && !isExampleSentenceContribution && !isCommonMistakeContribution && !isVideoGameQuoteContribution) {
              console.log('Not a community contribution PR, skipping');
              core.setOutput('should_commit', 'false');
              return;
            }

            const issueMatch = prBody.match(/[Cc]loses?\s*#(\d+)|[Ff]ixes?\s*#(\d+)|[Rr]esolves?\s*#(\d+)/);
            let targetIssue = null;

            if (issueMatch) {
              targetIssue = parseInt(issueMatch[1] || issueMatch[2] || issueMatch[3]);
              console.log(`Found linked issue in PR body: #${targetIssue}`);
            }

            if (!targetIssue) {
              console.log('No issue linked, searching for matching issue...');

              async function searchOpenCommunityIssues(query) {
                const q = `${query} repo:${context.repo.owner}/${context.repo.repo} is:issue is:open label:${templates.labels.community}`;
                const res = await github.rest.search.issuesAndPullRequests({
                  q: q,
                  per_page: 10
                });
                return res.data.items || [];
              }
              
              if (isThemeContribution) {
                let themeName = null;
                const patterns = [
                  /add\s+(.+?)\s+theme/i,
                  /theme[:\s]+(.+)/i,
                  /feat\(theme\)[:\s]+add\s+(.+)/i
                ];
                
                for (const pattern of patterns) {
                  const match = prTitle.match(pattern);
                  if (match) {
                    themeName = match[1].trim().replace(/theme$/i, '').trim();
                    break;
                  }
                }
                
                if (themeName) {
                  console.log(`Looking for theme issue: ${themeName}`);
                  const matches = await searchOpenCommunityIssues(`"Add Theme:" "${themeName}"`);
                  if (matches.length === 0) {
                    // Fallback: try old title format for pre-migration issues
                    const oldMatches = await searchOpenCommunityIssues(`"Add New Color Theme:" "${themeName}"`);
                    if (oldMatches.length > 0) { targetIssue = oldMatches[0].number; }
                  } else {
                    targetIssue = matches[0].number;
                    console.log(`Found matching theme issue: #${targetIssue}`);
                  }
                }
              } else if (isFactContribution) {
                const factIdMatch = prTitle.match(/#(\d+)/);
                const factId = factIdMatch ? factIdMatch[1] : null;
                if (factId) {
                  console.log(`Looking for fact issue: #${factId}`);
                  const matches = await searchOpenCommunityIssues(`"Add Japan Fact #${factId}"`);
                  if (matches.length > 0) {
                    targetIssue = matches[0].number;
                    console.log(`Found matching fact issue: #${targetIssue}`);
                  }
                }
              } else if (isProverbContribution) {
                const proverbIdMatch = prTitle.match(/#(\d+)/);
                const proverbId = proverbIdMatch ? proverbIdMatch[1] : null;
                if (proverbId) {
                  console.log(`Looking for proverb issue: #${proverbId}`);
                  const matches = await searchOpenCommunityIssues(`"Add Japanese Proverb #${proverbId}"`);
                  if (matches.length > 0) {
                    targetIssue = matches[0].number;
                    console.log(`Found matching proverb issue: #${targetIssue}`);
                  }
                }
              } else if (isHaikuContribution) {
                const haikuIdMatch = prTitle.match(/#(\d+)/);
                const haikuId = haikuIdMatch ? haikuIdMatch[1] : null;
                if (haikuId) {
                  const matches = await searchOpenCommunityIssues(`"Add Japanese Haiku #${haikuId}"`);
                  if (matches.length === 0) {
                    const oldMatches = await searchOpenCommunityIssues(`"Add Classic Japanese Haiku #${haikuId}"`);
                    if (oldMatches.length > 0) { targetIssue = oldMatches[0].number; }
                  } else { targetIssue = matches[0].number; }
                }
              } else if (isTriviaContribution) {
                const triviaIdMatch = prTitle.match(/#(\d+)/);
                const triviaId = triviaIdMatch ? triviaIdMatch[1] : null;
                if (triviaId) {
                  console.log(`Looking for trivia issue: #${triviaId}`);
                  const matches = await searchOpenCommunityIssues(`"Add Trivia Question #${triviaId}"`);
                  if (matches.length === 0) {
                    const old = await searchOpenCommunityIssues(`"Add New Trivia Question #${triviaId}"`);
                    if (old.length > 0) { targetIssue = old[0].number; console.log(`Found matching trivia issue: #${targetIssue}`); }
                  } else { targetIssue = matches[0].number; console.log(`Found matching trivia issue: #${targetIssue}`); }
                }
              } else if (isGrammarContribution) {
                const grammarIdMatch = prTitle.match(/#(\d+)/);
                const grammarId = grammarIdMatch ? grammarIdMatch[1] : null;
                if (grammarId) {
                  console.log(`Looking for grammar issue: #${grammarId}`);
                  const matches = await searchOpenCommunityIssues(`"Add Grammar Point #${grammarId}"`);
                  if (matches.length === 0) {
                    const old = await searchOpenCommunityIssues(`"Add New Grammar Point #${grammarId}"`);
                    if (old.length > 0) { targetIssue = old[0].number; console.log(`Found matching grammar issue: #${targetIssue}`); }
                  } else { targetIssue = matches[0].number; console.log(`Found matching grammar issue: #${targetIssue}`); }
                }
              } else if (isAnimeQuoteContribution) {
                const quoteIdMatch = prTitle.match(/#(\d+)/);
                const quoteId = quoteIdMatch ? quoteIdMatch[1] : null;
                if (quoteId) {
                  console.log(`Looking for anime quote issue: #${quoteId}`);
                  const matches = await searchOpenCommunityIssues(`"Add Anime Quote #${quoteId}"`);
                  if (matches.length === 0) {
                    const old = await searchOpenCommunityIssues(`"Add Famous Anime Quote #${quoteId}"`);
                    if (old.length > 0) { targetIssue = old[0].number; console.log(`Found matching anime quote issue: #${targetIssue}`); }
                  } else { targetIssue = matches[0].number; console.log(`Found matching anime quote issue: #${targetIssue}`); }
                }
              } else if (isIdiomContribution) {
                const idiomIdMatch = prTitle.match(/#(\d+)/);
                const idiomId = idiomIdMatch ? idiomIdMatch[1] : null;
                if (idiomId) {
                  console.log(`Looking for idiom issue: #${idiomId}`);
                  const matches = await searchOpenCommunityIssues(`"Add Japanese Idiom #${idiomId}"`);
                  if (matches.length === 0) {
                    const old = await searchOpenCommunityIssues(`"Add New Japanese Idiom #${idiomId}"`);
                    if (old.length > 0) { targetIssue = old[0].number; console.log(`Found matching idiom issue: #${targetIssue}`); }
                  } else { targetIssue = matches[0].number; console.log(`Found matching idiom issue: #${targetIssue}`); }
                }
              } else if (isRegionalDialectContribution) {
                const dialectIdMatch = prTitle.match(/#(\d+)/);
                const dialectId = dialectIdMatch ? dialectIdMatch[1] : null;
                if (dialectId) {
                  console.log(`Looking for regional dialect issue: #${dialectId}`);
                  const matches = await searchOpenCommunityIssues(`"Add Dialect Entry #${dialectId}"`);
                  if (matches.length === 0) {
                    const old = await searchOpenCommunityIssues(`"Add Regional Dialect Entry #${dialectId}"`);
                    if (old.length > 0) { targetIssue = old[0].number; console.log(`Found matching regional dialect issue: #${targetIssue}`); }
                  } else { targetIssue = matches[0].number; console.log(`Found matching regional dialect issue: #${targetIssue}`); }
                }
              } else if (isFalseFriendContribution) {
                const idMatch = prTitle.match(/#(\d+)/);
                const id = idMatch ? idMatch[1] : null;
                if (id) {
                  const matches = await searchOpenCommunityIssues(`"Add False Friend Pair #${id}"`);
                  if (matches.length === 0) {
                    const old = await searchOpenCommunityIssues(`"Add Japanese False Friend #${id}"`);
                    if (old.length > 0) { targetIssue = old[0].number; }
                  } else { targetIssue = matches[0].number; }
                }
              } else if (isCulturalEtiquetteContribution) {
                const idMatch = prTitle.match(/#(\d+)/);
                const id = idMatch ? idMatch[1] : null;
                if (id) {
                  const matches = await searchOpenCommunityIssues(`"Add Etiquette Tip #${id}"`);
                  if (matches.length === 0) {
                    const old = await searchOpenCommunityIssues(`"Add Japanese Cultural Etiquette Tip #${id}"`);
                    if (old.length > 0) { targetIssue = old[0].number; }
                  } else { targetIssue = matches[0].number; }
                }
              } else if (isExampleSentenceContribution) {
                const idMatch = prTitle.match(/#(\d+)/);
                const id = idMatch ? idMatch[1] : null;
                if (id) {
                  const matches = await searchOpenCommunityIssues(`"Add Example Sentence #${id}"`);
                  if (matches.length === 0) {
                    const old = await searchOpenCommunityIssues(`"Add Japanese Example Sentence #${id}"`);
                    if (old.length > 0) { targetIssue = old[0].number; }
                  } else { targetIssue = matches[0].number; }
                }
              } else if (isCommonMistakeContribution) {
                const idMatch = prTitle.match(/#(\d+)/);
                const id = idMatch ? idMatch[1] : null;
                if (id) {
                  const matches = await searchOpenCommunityIssues(`"Add Learner Mistake #${id}"`);
                  if (matches.length === 0) {
                    const old = await searchOpenCommunityIssues(`"Add Common Japanese Learner Mistake #${id}"`);
                    if (old.length > 0) { targetIssue = old[0].number; }
                  } else { targetIssue = matches[0].number; }
                }
              } else if (isVideoGameQuoteContribution) {
                const idMatch = prTitle.match(/#(\d+)/);
                const id = idMatch ? idMatch[1] : null;
                if (id) {
                  const matches = await searchOpenCommunityIssues(`"Add Video Game Quote #${id}"`);
                  if (matches.length === 0) {
                    const old = await searchOpenCommunityIssues(`"Add Famous Japanese Video Game Quote #${id}"`);
                    if (old.length > 0) { targetIssue = old[0].number; }
                  } else { targetIssue = matches[0].number; }
                }
              }
            }

            let needsCommit = false;

            if (targetIssue) {
              try {
                const { data: issueData } = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: targetIssue
                });

                const issueTitle = issueData.title || '';
                const issueTitleLower = issueTitle.toLowerCase();

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: targetIssue,
                  body: `${t.title}\n\n${t.body.replace('{author}', prAuthor)}\n\n${t.mergedIn.replace('{prNumber}', prNumber)}\n\n${t.footer}`
                });
                
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: targetIssue,
                  state: 'closed',
                  state_reason: 'completed'
                });
                
                console.log(`Successfully closed issue #${targetIssue}`);
                
                // Mark the item as permanently completed in the backlog
                if (isThemeContribution) {
                  const themes = JSON.parse(fs.readFileSync(themeBacklogPath, 'utf8'));
                  // Prefer extracting theme name from the issue title
                  let themeName = null;

                  const issueThemeMatch = issueTitle.match(/Add (?:new )?(?:New Color )?Theme:\s*(.+?)(?:\s*(?:—|\()|$)/i);
                  if (issueThemeMatch) {
                    themeName = issueThemeMatch[1].trim();
                  }

                  // Fallback: try to find theme by PR title
                  const patterns = [
                    /add\s+(.+?)\s+theme/i,
                    /theme[:\s]+(.+)/i,
                    /feat\(theme\)[:\s]+add\s+(.+)/i
                  ];
                  for (const pattern of patterns) {
                    const match = prTitle.match(pattern);
                    if (match) {
                      themeName = match[1].trim().replace(/theme$/i, '').trim();
                      break;
                    }
                  }
                  if (themeName) {
                    const themeIndex = themes.findIndex(function(th) {
                      return th.name.toLowerCase() === themeName.toLowerCase();
                    });
                    if (themeIndex !== -1) {
                      themes[themeIndex].issued = false;
                      themes[themeIndex].completed = true;
                      themes[themeIndex].completedBy = prAuthor;
                      themes[themeIndex].completedPR = prNumber;
                      fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                      needsCommit = true;
                      console.log(`Marked theme "${themeName}" as completed`);
                    }
                  }
                } else if (isFactContribution) {
                  const facts = JSON.parse(fs.readFileSync(factsBacklogPath, 'utf8'));
                  const issueFactMatch = issueTitle.match(/Add (?:new )?Japan Fact\s*#(\d+)/i);
                  const prFactMatch = prTitle.match(/#(\d+)/);
                  const factId = issueFactMatch ? parseInt(issueFactMatch[1]) : (prFactMatch ? parseInt(prFactMatch[1]) : null);

                  if (factId !== null) {
                    const factIndex = facts.findIndex(function(f) { return f.id === factId; });
                    if (factIndex !== -1) {
                      facts[factIndex].issued = false;
                      facts[factIndex].completed = true;
                      facts[factIndex].completedBy = prAuthor;
                      facts[factIndex].completedPR = prNumber;
                      fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
                      needsCommit = true;
                      console.log(`Marked fact #${factId} as completed`);
                    }
                  }
                } else if (isProverbContribution) {
                  const proverbs = JSON.parse(fs.readFileSync(proverbsBacklogPath, 'utf8'));
                  const issueProverbMatch = issueTitle.match(/Add (?:new )?Japanese Proverb\s*#(\d+)/i);
                  const prProverbMatch = prTitle.match(/#(\d+)/);
                  const proverbId = issueProverbMatch ? parseInt(issueProverbMatch[1]) : (prProverbMatch ? parseInt(prProverbMatch[1]) : null);

                  if (proverbId !== null) {
                    const proverbIndex = proverbs.findIndex(function(p) { return p.id === proverbId; });
                    if (proverbIndex !== -1) {
                      proverbs[proverbIndex].issued = false;
                      proverbs[proverbIndex].completed = true;
                      proverbs[proverbIndex].completedBy = prAuthor;
                      proverbs[proverbIndex].completedPR = prNumber;
                      fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
                      needsCommit = true;
                      console.log(`Marked proverb #${proverbId} as completed`);
                    }
                  }
                } else if (isHaikuContribution) {
                  const haikuItems = JSON.parse(fs.readFileSync(haikuBacklogPath, 'utf8'));
                  const issueHaikuMatch = issueTitle.match(/Add (?:new )?(?:Classic )?Japanese Haiku\s*#(\d+)/i);
                  const prHaikuMatch = prTitle.match(/#(\d+)/);
                  const haikuId = issueHaikuMatch ? parseInt(issueHaikuMatch[1]) : (prHaikuMatch ? parseInt(prHaikuMatch[1]) : null);

                  if (haikuId !== null) {
                    const haikuIndex = haikuItems.findIndex(function(h) { return h.id === haikuId; });
                    if (haikuIndex !== -1) {
                      haikuItems[haikuIndex].issued = false;
                      haikuItems[haikuIndex].completed = true;
                      haikuItems[haikuIndex].completedBy = prAuthor;
                      haikuItems[haikuIndex].completedPR = prNumber;
                      fs.writeFileSync(haikuBacklogPath, JSON.stringify(haikuItems, null, 2));
                      needsCommit = true;
                      console.log(`Marked haiku #${haikuId} as completed`);
                    }
                  }
                } else if (isTriviaContribution) {
                  const trivia = JSON.parse(fs.readFileSync(triviaBacklogPath, 'utf8'));
                  const issueTriviaMatch = issueTitle.match(/Add (?:new )?(?:New )?Trivia Question\s*#(\d+)/i);
                  const prTriviaMatch = prTitle.match(/#(\d+)/);
                  const triviaId = issueTriviaMatch ? parseInt(issueTriviaMatch[1]) : (prTriviaMatch ? parseInt(prTriviaMatch[1]) : null);

                  if (triviaId !== null) {
                    const triviaIndex = trivia.findIndex(function(q) { return q.id === triviaId; });
                    if (triviaIndex !== -1) {
                      trivia[triviaIndex].issued = false;
                      trivia[triviaIndex].completed = true;
                      trivia[triviaIndex].completedBy = prAuthor;
                      trivia[triviaIndex].completedPR = prNumber;
                      fs.writeFileSync(triviaBacklogPath, JSON.stringify(trivia, null, 2));
                      needsCommit = true;
                      console.log(`Marked trivia #${triviaId} as completed`);
                    }
                  }
                } else if (isGrammarContribution) {
                  const grammar = JSON.parse(fs.readFileSync(grammarBacklogPath, 'utf8'));
                  const issueGrammarMatch = issueTitle.match(/Add (?:new )?(?:New )?Grammar Point\s*#(\d+)/i);
                  const prGrammarMatch = prTitle.match(/#(\d+)/);
                  const grammarId = issueGrammarMatch ? parseInt(issueGrammarMatch[1]) : (prGrammarMatch ? parseInt(prGrammarMatch[1]) : null);

                  if (grammarId !== null) {
                    const grammarIndex = grammar.findIndex(function(g) { return g.id === grammarId; });
                    if (grammarIndex !== -1) {
                      grammar[grammarIndex].issued = false;
                      grammar[grammarIndex].completed = true;
                      grammar[grammarIndex].completedBy = prAuthor;
                      grammar[grammarIndex].completedPR = prNumber;
                      fs.writeFileSync(grammarBacklogPath, JSON.stringify(grammar, null, 2));
                      needsCommit = true;
                      console.log(`Marked grammar #${grammarId} as completed`);
                    }
                  }
                } else if (isAnimeQuoteContribution) {
                  const animeQuotes = JSON.parse(fs.readFileSync(animeQuotesBacklogPath, 'utf8'));
                  const issueQuoteMatch = issueTitle.match(/Add (?:new )?(?:Famous )?Anime Quote\s*#(\d+)/i);
                  const prQuoteMatch = prTitle.match(/#(\d+)/);
                  const quoteId = issueQuoteMatch ? parseInt(issueQuoteMatch[1]) : (prQuoteMatch ? parseInt(prQuoteMatch[1]) : null);

                  if (quoteId !== null) {
                    const quoteIndex = animeQuotes.findIndex(function(q) { return q.id === quoteId; });
                    if (quoteIndex !== -1) {
                      animeQuotes[quoteIndex].issued = false;
                      animeQuotes[quoteIndex].completed = true;
                      animeQuotes[quoteIndex].completedBy = prAuthor;
                      animeQuotes[quoteIndex].completedPR = prNumber;
                      fs.writeFileSync(animeQuotesBacklogPath, JSON.stringify(animeQuotes, null, 2));
                      needsCommit = true;
                      console.log(`Marked anime quote #${quoteId} as completed`);
                    }
                  }
                } else if (isIdiomContribution) {
                  const idioms = JSON.parse(fs.readFileSync(idiomsBacklogPath, 'utf8'));
                  const issueIdiomMatch = issueTitle.match(/Add (?:new )?(?:New )?Japanese Idiom\s*#(\d+)/i);
                  const prIdiomMatch = prTitle.match(/#(\d+)/);
                  const idiomId = issueIdiomMatch ? parseInt(issueIdiomMatch[1]) : (prIdiomMatch ? parseInt(prIdiomMatch[1]) : null);

                  if (idiomId !== null) {
                    const idiomIndex = idioms.findIndex(function(i) { return i.id === idiomId; });
                    if (idiomIndex !== -1) {
                      idioms[idiomIndex].issued = false;
                      idioms[idiomIndex].completed = true;
                      idioms[idiomIndex].completedBy = prAuthor;
                      idioms[idiomIndex].completedPR = prNumber;
                      fs.writeFileSync(idiomsBacklogPath, JSON.stringify(idioms, null, 2));
                      needsCommit = true;
                      console.log(`Marked idiom #${idiomId} as completed`);
                    }
                  }
                } else if (isRegionalDialectContribution) {
                  const regionalDialects = JSON.parse(fs.readFileSync(regionalDialectsBacklogPath, 'utf8'));
                  const issueDialectMatch = issueTitle.match(/Add (?:new )?(?:Regional )?Dialect Entry\s*#(\d+)/i);
                  const prDialectMatch = prTitle.match(/#(\d+)/);
                  const dialectId = issueDialectMatch ? parseInt(issueDialectMatch[1]) : (prDialectMatch ? parseInt(prDialectMatch[1]) : null);

                  if (dialectId !== null) {
                    const dialectIndex = regionalDialects.findIndex(function(d) { return d.id === dialectId; });
                    if (dialectIndex !== -1) {
                      regionalDialects[dialectIndex].issued = false;
                      regionalDialects[dialectIndex].completed = true;
                      regionalDialects[dialectIndex].completedBy = prAuthor;
                      regionalDialects[dialectIndex].completedPR = prNumber;
                      fs.writeFileSync(regionalDialectsBacklogPath, JSON.stringify(regionalDialects, null, 2));
                      needsCommit = true;
                      console.log(`Marked regional dialect #${dialectId} as completed`);
                    }
                  }
                } else if (isFalseFriendContribution) {
                  const items = JSON.parse(fs.readFileSync(falseFriendsBacklogPath, 'utf8'));
                  const issueMatch = issueTitle.match(/Add (?:new )?(?:Japanese )?False Friend(?:\s*Pair)?\s*#(\d+)/i);
                  const prMatch = prTitle.match(/#(\d+)/);
                  const id = issueMatch ? parseInt(issueMatch[1]) : (prMatch ? parseInt(prMatch[1]) : null);

                  if (id !== null) {
                    const idx = items.findIndex(function(i) { return i.id === id; });
                    if (idx !== -1) {
                      items[idx].issued = false;
                      items[idx].completed = true;
                      items[idx].completedBy = prAuthor;
                      items[idx].completedPR = prNumber;
                      fs.writeFileSync(falseFriendsBacklogPath, JSON.stringify(items, null, 2));
                      needsCommit = true;
                      console.log(`Marked false friend #${id} as completed`);
                    }
                  }
                } else if (isCulturalEtiquetteContribution) {
                  const items = JSON.parse(fs.readFileSync(culturalEtiquetteBacklogPath, 'utf8'));
                  const issueMatch = issueTitle.match(/Add (?:new )?(?:Japanese Cultural )?Etiquette Tip\s*#(\d+)/i);
                  const prMatch = prTitle.match(/#(\d+)/);
                  const id = issueMatch ? parseInt(issueMatch[1]) : (prMatch ? parseInt(prMatch[1]) : null);

                  if (id !== null) {
                    const idx = items.findIndex(function(i) { return i.id === id; });
                    if (idx !== -1) {
                      items[idx].issued = false;
                      items[idx].completed = true;
                      items[idx].completedBy = prAuthor;
                      items[idx].completedPR = prNumber;
                      fs.writeFileSync(culturalEtiquetteBacklogPath, JSON.stringify(items, null, 2));
                      needsCommit = true;
                      console.log(`Marked cultural etiquette #${id} as completed`);
                    }
                  }
                } else if (isExampleSentenceContribution) {
                  const items = JSON.parse(fs.readFileSync(exampleSentencesBacklogPath, 'utf8'));
                  const issueMatch = issueTitle.match(/Add (?:new )?(?:Japanese )?Example Sentence\s*#(\d+)/i);
                  const prMatch = prTitle.match(/#(\d+)/);
                  const id = issueMatch ? parseInt(issueMatch[1]) : (prMatch ? parseInt(prMatch[1]) : null);

                  if (id !== null) {
                    const idx = items.findIndex(function(i) { return i.id === id; });
                    if (idx !== -1) {
                      items[idx].issued = false;
                      items[idx].completed = true;
                      items[idx].completedBy = prAuthor;
                      items[idx].completedPR = prNumber;
                      fs.writeFileSync(exampleSentencesBacklogPath, JSON.stringify(items, null, 2));
                      needsCommit = true;
                      console.log(`Marked example sentence #${id} as completed`);
                    }
                  }
                } else if (isCommonMistakeContribution) {
                  const items = JSON.parse(fs.readFileSync(commonMistakesBacklogPath, 'utf8'));
                  const issueMatch = issueTitle.match(/Add (?:new )?(?:Common Japanese )?Learner Mistake\s*#(\d+)/i);
                  const prMatch = prTitle.match(/#(\d+)/);
                  const id = issueMatch ? parseInt(issueMatch[1]) : (prMatch ? parseInt(prMatch[1]) : null);

                  if (id !== null) {
                    const idx = items.findIndex(function(i) { return i.id === id; });
                    if (idx !== -1) {
                      items[idx].issued = false;
                      items[idx].completed = true;
                      items[idx].completedBy = prAuthor;
                      items[idx].completedPR = prNumber;
                      fs.writeFileSync(commonMistakesBacklogPath, JSON.stringify(items, null, 2));
                      needsCommit = true;
                      console.log(`Marked common mistake #${id} as completed`);
                    }
                  }
                } else if (isVideoGameQuoteContribution) {
                  const items = JSON.parse(fs.readFileSync(videoGameQuotesBacklogPath, 'utf8'));
                  const issueMatch = issueTitle.match(/Add (?:new )?(?:Famous Japanese )?Video Game Quote\s*#(\d+)/i);
                  const prMatch = prTitle.match(/#(\d+)/);
                  const id = issueMatch ? parseInt(issueMatch[1]) : (prMatch ? parseInt(prMatch[1]) : null);

                  if (id !== null) {
                    const idx = items.findIndex(function(i) { return i.id === id; });
                    if (idx !== -1) {
                      items[idx].issued = false;
                      items[idx].completed = true;
                      items[idx].completedBy = prAuthor;
                      items[idx].completedPR = prNumber;
                      fs.writeFileSync(videoGameQuotesBacklogPath, JSON.stringify(items, null, 2));
                      needsCommit = true;
                      console.log(`Marked video game quote #${id} as completed`);
                    }
                  }
                }
              } catch (e) {
                console.log(`Error closing issue: ${e.message}`);
              }
            } else {
              console.log('No matching issue found to close');
            }

            core.setOutput('should_commit', needsCommit ? 'true' : 'false');

      - name: Commit backlog updates directly to main
        if: steps.close-issue.outputs.should_commit == 'true'
        run: |
          git config user.name "てんとう虫"
          git config user.email "reservecrate@gmail.com"
          git add community/backlog/
          if git diff --cached --quiet; then
            echo "No backlog changes to commit"
            exit 0
          fi
          commit_msg="chore(automation): mark contribution as completed"
          max_attempts=5
          attempt=1
          while [ "$attempt" -le "$max_attempts" ]; do
            git commit -m "$commit_msg"
            if git pull --rebase origin main && git push origin HEAD:main; then
              echo "Backlog push succeeded on attempt $attempt"
              exit 0
            fi
            echo "Backlog push attempt $attempt failed; retrying..."
            git rebase --abort || true
            git fetch origin main
            git reset --hard origin/main
            git add community/backlog/
            if git diff --cached --quiet; then
              echo "No backlog changes remain after sync"
              exit 0
            fi
            attempt=$((attempt + 1))
          done
          echo "Failed to push backlog updates after $max_attempts attempts"
          exit 1
